## Shadow

# Enabled client-side shadows on windows
shadow = true;

# Don't draw shadows on DND windows
no-dnd-shadow = true;

# Avoid drawing shadows on dock/panel windows
no-dock-shadow = true;

# Zero the part of the shadow's mask behind the window (experimental)
clear-shadow = true;

# The blur radius for shadows. (default 12)
shadow-radius = 7;

# The left offset for shadows. (default -15)
shadow-offset-x = -7;

# The top offset for shadows. (default -15)
shadow-offset-y = -7;

# Do not paint shadows on shaped windows. Note shaped windows here means windows setting its shape through X Shape extension. Those using ARGB background is beyond our control
shadow-ignore-shaped = true;

# Specify a list of conditions of windows that should have no shadow
shadow-exclude = [ "n:e:Notification", "class_g = 'Conky'" ];

# The translucency for shadows. (default .75)
# shadow-opacity = 0.7;

# Red color value of shadow. (0.0 - 1.0, defaults to 0)
# shadow-red = 0.0;

# Green color value of shadow. (0.0 - 1.0, defaults to 0)
# shadow-green = 0.0;

# Blue color value of shadow. (0.0 - 1.0, defaults to 0)
# shadow-blue = 0.0;


## Opacity

# The opacity for menus. (default 1.0)
menu-opacity = 1;

# Opacity of inactive windows. (0.1 - 1.0)
inactive-opacity = 1;

# Inactive opacity set by 'inactive-opacity' overrides value of _NET_WM_OPACITY.
inactive-opacity-override = true;

# Opacity of window titlebars and borders. (0.1 - 1.0)
frame-opacity = 0.99;

# Step for pregenerating alpha pictures. (0.01 - 1.0, defaults to 0.03)
# alpha-step = 0.06;

# Dim inactive windows. (0.0 - 1.0, defaults to 0)
# inactive-dim = 0.5

# Use fixed inactive dim value, instead of adjusting according to window opacity
# inactive-dim-fixed = true;

# Blur background of semi-transparent / ARGB windows. Bad in performance, with driver-dependent behavior. The name of the switch may change without prior notifications
# blur-background = true;

# Blur background of windows when the window frame is not opaque. Implies --blur-background. Bad in performance, with driver-dependent behavior. The name may change
# blur-background-frame = true;

# Use fixed blur strength rather than adjusting according to window opacity
# blur-background-fixed = false;

#blur-background-exclude = [ "window_type = 'dock'", "window_type = 'desktop'" ];


## Fading

# Fade windows during opacity changes
fading = true;

# The time between steps in a fade in milliseconds. (default 10)
# fade-delta = 30;

# Opacity change between steps while fading in. (default 0.028)
fade-in-step = 0.03;

# Opacity change between steps while fading out
fade-out-step = 0.03;

# Fade windows in/out when opening/closing
# no-fading-openclose = true;

# Specify a list of conditions of windows that should not be faded
# fade-exclude = [ ];

# Specify a list of conditions of windows that should always be considered focused
# focus-exclude = [ ];


## Other

# Try to detect WM windows and mark them as active
mark-wmwin-focused = true;
mark-ovredir-focused = true;

# Try to detect windows with rounded corners and don’t consider them shaped windows
detect-rounded-corners = true;

# Detect _NET_WM_OPACITY on client windows, useful for window managers not passing _NET_WM_OPACITY of client windows to frame windows
# detect-client-opacity = true

# Specify the backend to use: xrender` or 'glx. GLX (OpenGL) backend generally has much superior performance as far as you have a graphic card/chip and driver
backend = "glx";

# Use EWMH _NET_ACTIVE_WINDOW to determine currently focused window, rather than listening to FocusIn/FocusOut event. Might have more accuracy, provided that the WM supports it. Experimental
# use-ewmh-active-win = false;

# Specify refresh rate of the screen. If not specified or 0, compton will try detecting this with X RandR extension
refresh-rate = 0;

# Set VSync method to opengl-swc. Try to VSync with SGI_swap_control OpenGL extension. Only work on some drivers. Works only with GLX backend. Known to be most effective on many drivers
vsync = "opengl-swc";

# Painting on X Composite overlay window instead of on root window
paint-on-overlay = true;

# Limit compton to repaint at most once every 1 / refresh_rate second to boost performance. Experimental. This should not be used with --vsync as --vsync essentially does --sw-opti's job already, unless you wish to specify a lower refresh rate than the actual value
sw-opti = false;

#Unredirect all windows if a full-screen opaque window is detected, to maximize performance for full-screen windows. Known to cause flickering when redirecting/unredirecting windows. --paint-on-overlay may make the flickering less obvious. Experimental
# unredir-if-possible = false;

# Use WM_TRANSIENT_FOR to group windows, and consider windows in the same group focused at the same time
# detect-transient = true;

# Use WM_CLIENT_LEADER to group windows, and consider windows in the same group focused at the same time. WM_TRANSIENT_FOR has higher priority if --detect-transient is enabled, too
# detect-client-leader = true;

# Specify a list of conditions of windows that should be painted with inverted color. Resource-hogging, and is not well tested
# invert-color-include = [ ];


## GLX backend

# GLX backend: Avoid using stencil buffer, useful if you don’t have a stencil buffer. Might cause incorrect opacity when rendering transparent content and cannot work with --blur-background. My tests show a 15% performance boost
glx-no-stencil = true;

# GLX backend: Copy unmodified regions from front buffer instead of redrawing them all. My tests with nvidia-drivers show a 10% decrease in performance when the whole screen is modified, but a 20% increase when only 1/4 is. My tests on nouveau show terrible slowdown
# glx-copy-from-front = false;

# GLX backend: Use MESA_copy_sub_buffer to do partial screen update. My tests on nouveau shows a 200% performance boost when only 1/4 of the screen is updated. May break VSync and is not available on some drivers. Overrides --glx-copy-from-front
# glx-use-copysubbuffermesa = false;

# GLX backend: Avoid rebinding pixmap on window damage. Probably could improve performance on rapid window content changes, but is known to break things on some drivers (LLVMpipe)
glx-no-rebind-pixmap = true;

# GLX backend: GLX buffer swap method we assume. Could be undefined (0), copy (1), exchange (2), 3-6, or buffer-age (-1). undefined is the slowest and the safest, and the default value. copy is fastest, but may fail on some drivers, 2-6 are gradually slower but safer (6 is still faster than 0). Usually, double buffer means 2, triple buffer means 3. buffer-age means auto-detect using GLX_EXT_buffer_age, supported by some drivers. Useless with --glx-use-copysubbuffermesa. Partially breaks --resize-damage. Defaults to undefined
glx-swap-method = "undefined";


## Window type settings

wintypes:
{
  tooltip = { fade = true; shadow = false; opacity = 0; };
};
